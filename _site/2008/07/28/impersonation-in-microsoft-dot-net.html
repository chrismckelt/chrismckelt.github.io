
<p>j
hn—
layout: post
category: posts
title: “Impersonation in Microsoft Dot Net”
date: “2008-07-28”
categories:</p>
<ul>
  <li>
    <h2 id="net">“net”</h2>
  </li>
</ul>

<p><em><strong>Usage</strong></em></p>

<p>string domain = “ExampleDomain”;
string userName = “ExampleUserName”;
string password = “ExamplePassword”;</p>

<p>using (Impersonation impersonation = new Impersonation(domain, userName, password))
{
 // impersonation occuring in here 
         Console.WriteLine(System.Security.Principal.WindowsIdentity.GetCurrent().Name);
}</p>

<p><em><strong>Implementation</strong></em></p>

<p>using System;
using System.Runtime.InteropServices;
using System.Security.Permissions;
using System.Security.Principal;</p>

<p>namespace ExampleNameSpace</p>

<p>{
     public class Impersonation : IDisposable
        {
            private bool _disposed = false;
            private WindowsImpersonationContext _wc;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        #region Win32 Interop
        // Win32 declarations (constants, enumerations, functions etc.)
        public const int LOGON32\_LOGON\_INTERACTIVE = 2;
        public const int LOGON32\_PROVIDER\_DEFAULT = 0;

        \[DllImport("kernel32.dll", CallingConvention = CallingConvention.Winapi, SetLastError = true)\]
        public static extern int CloseHandle(
            IntPtr handle);

        \[DllImport("advapi32.dll", CharSet = CharSet.Auto, SetLastError = true)\]
        public static extern int DuplicateToken(IntPtr hToken,
            int impersonationLevel,
            ref IntPtr hNewToken);

        \[DllImport("advapi32.dll")\]
        public static extern int LogonUserA(String lpszUserName,
            String lpszDomain,
            String lpszPassword,
            int dwLogonType,
            int dwLogonProvider,
            ref IntPtr phToken);

        \[DllImport("advapi32.dll", CharSet = CharSet.Auto, SetLastError = true)\]
        public static extern bool RevertToSelf();
        #endregion

        /// &lt;summary&gt;
        /// Constructor begins impersonation based on user credentials passed in. 
        /// &lt;/summary&gt;
        /// &lt;param name="domain"&gt;Windows Domain&lt;/param&gt;
        /// &lt;param name="userName"&gt;Windows username&lt;/param&gt;
        /// &lt;param name="password"&gt;Windows password&lt;/param&gt;
        public Impersonation(string domain, string userName, string password)
        {
            if (!string.IsNullOrEmpty(password))
            {
                \_wc = WindowsIdentity.GetCurrent().Impersonate();
                ImpersonateValidUser(domain, userName, password);
            }
        }

        /// &lt;summary&gt;
        /// This destructor will run only if the Dispose method does not get called.
        /// &lt;/summary&gt;
        ~Impersonation()
        {
            Dispose(false);
        }

        /// &lt;summary&gt;
        /// Dispose(bool disposing) executes in two distinct scenarios. If disposing equals true, the method
        /// has been called directly or indirectly by a user's code. Managed and unmanaged resources can be
        /// disposed. If disposing equals false, the method has been called by the runtime from inside the
        /// finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
        /// &lt;/summary&gt;
        /// &lt;param name="disposing"&gt;True if function called from user code, false if called from finalizer.&lt;/param&gt;
        private void Dispose(bool disposing)
        {
            // Check to see if Dispose has already been called
            if (!\_disposed)
            {
                // If disposing equals true, dispose all managed and unmanaged resources
                if (disposing)
                {
                    // Dispose managed resources (there are none)
                }

                // Clean up unmanaged resources here (there are none)

                // Reset impersonation
                UndoImpersonation();
            }
            \_disposed = true;
        }

        /// &lt;summary&gt;
        /// Implement IDisposable.
        /// &lt;/summary&gt;
        public void Dispose()
        {
            // Clean up this object
            Dispose(true);

            // Take this object off the finalization queue and prevent finalization code for this object
            // from executing a second time.
            GC.SuppressFinalize(this);
        }

        /// &lt;summary&gt;
        /// This function can be used to impersonate a specific user while a section of code is run.
        /// This code is taken from the Microsoft Knowledge Base, article KB30615, "How to implement
        /// impersonation in an ASP.NET application".
        /// &lt;/summary&gt;
        /// &lt;param name="domain"&gt;Windows domain&lt;/param&gt;
        /// &lt;param name="userName"&gt;The user that is being impersonated.  This can be a user SAM account
        /// name or a user principal name. Whether or not UPN is selected is detected by looking for an
        /// occurrence of the @ character in userName.&lt;/param&gt;
        /// &lt;param name="password"&gt;The user's password.&lt;/param&gt;
        /// &lt;returns&gt;True if impersonation works, false if impersonation fails.&lt;/returns&gt;
        \[PermissionSet(SecurityAction.Demand, Name = "FullTrust")\]
        public bool ImpersonateValidUser(string domain, string userName, string password)
        {
            WindowsIdentity tempWindowsIdentity;
            IntPtr token = IntPtr.Zero;
            IntPtr tokenDuplicate = IntPtr.Zero;

            if (RevertToSelf())
            {   
                if (LogonUserA(userName, domain, password, LOGON32\_LOGON\_INTERACTIVE, LOGON32\_PROVIDER\_DEFAULT, ref token) != 0)
                {
                    if (DuplicateToken(token, 2, ref tokenDuplicate) != 0)
                    {
                        tempWindowsIdentity = new WindowsIdentity(tokenDuplicate);
                        \_wc = tempWindowsIdentity.Impersonate();

                        if (\_wc != null)
                        {
                            CloseHandle(token);
                            CloseHandle(tokenDuplicate);
                            return true;
                        }
                    }
                }
            }

            if (token != IntPtr.Zero)
                CloseHandle(token);
            if (tokenDuplicate != IntPtr.Zero)
                CloseHandle(tokenDuplicate);
            return false;
        }

        /// &lt;summary&gt;
        /// Called after ImpersonateValidUser (see above).
        /// &lt;/summary&gt;
        /// &lt;param name="impersonationContext"&gt;An object that represents the Windows user prior to an
        /// impersonation operation.&lt;/param&gt;
        public void UndoImpersonation()
        {
            if (\_wc != null)
                \_wc.Undo();
        }
    } 
</code></pre></div></div>

<p>}</p>
